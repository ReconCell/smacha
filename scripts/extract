#! /usr/bin/env python

import os
import sys
import argparse

import smacha

if __name__ == '__main__':
    # Parse arguments
    arg_parser = argparse.ArgumentParser(description='SMACHA Extract: Extract a container state from a script and ' +
                                                     'save it as a sub-script.')
    
    arg_parser.add_argument('script_file',
                            action='store',
                            help='SMACHA script (yaml file).')
    
    arg_parser.add_argument('state',
                            action='store',
                            help='Name of container state to be extracted.')
    
    arg_parser.add_argument('-s', '--scripts',
                            nargs = '*',
                            dest='script_dirs',
                            action='store',
                            default=[],
                            help='SMACHA script directories (directories containing yaml files).')
    
    arg_parser.add_argument('-sub', '--sub-script-output',
                            dest='sub_script_output_file',
                            action='store',
                            default='./sub_script_output.yml',
                            help='Generated SMACHA sub-script output (YAML file).')
    
    arg_parser.add_argument('-sup', '--super-script-output',
                            dest='super_script_output_file',
                            action='store',
                            default='./super_script_output.yml',
                            help='Generated SMACHA super-script output (YAML file).')
    
    
    args = arg_parser.parse_args()
    
    # Load parser
    parser = smacha.Parser(script_dirs = args.script_dirs)
    
    # Load and parse SMACHA script
    script = parser.parse(args.script_file, include_line_numbers=False)

    # Find the container state
    for i_state, state in enumerate(script['states']):
        # Find the state name and variables in the current state
        state_name, state_vars = state.items()[0]

        # Check if it's the state we're looking for
        if state_name == args.state:
            break

    # Make note of persistent/non-persistent container and sub-script variables
    container_persistent_vars = ['params']
    sub_script_non_persistent_vars = ['states', 'template', 'script', 'input_keys', 'output_keys', 'outcomes']
    sub_script_persistent_vars = ['userdata', 'remapping', 'transitions']

    # Construct skeleton of super-script state entry 
    super_script_state_name = state_name
    super_script_state_vars = dict()
    super_script_state_vars['script'] = os.path.splitext(os.path.basename(args.sub_script_output_file))[0]
    
    # Construct skeleton of sub-script
    sub_script_name = state_name
    sub_script_state_vars = state_vars

    # Move persistent variables from the container state to the super-script
    for state_var, state_var_val in state_vars.items():
        if state_var in container_persistent_vars or state_var in sub_script_persistent_vars:
            # Add to super-script
            super_script_state_vars[state_var] = state_var_val
            # Remove from sub-script
            sub_script_state_vars.pop(state_var, 0)

    # Update the super-script state entry
    super_script_state = dict()
    super_script_state[super_script_state_name] = super_script_state_vars
    script['states'][i_state] = super_script_state
    
    # Update the sub-script
    sub_script_state = dict()
    sub_script_state[sub_script_name] = sub_script_state_vars
    
    # Write the updated super-script to a YAML file
    parser.dump(args.super_script_output_file, script)

    # Write the sub-script to a YAML file
    parser.dump(args.sub_script_output_file, [sub_script_state])
