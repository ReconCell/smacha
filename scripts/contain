#! /usr/bin/env python

import os
import sys
import argparse

import smacha
from smacha.exceptions import ParsingError

if __name__ == '__main__':
    # Parse arguments
    arg_parser = argparse.ArgumentParser(description='SMACHA Contain: Pack a series of states in a script into a' +
                                                     'container state and save the resulting script.')
    
    arg_parser.add_argument('script_file',
                            action='store',
                            help='SMACHA script (yaml file).')
    
    arg_parser.add_argument('container_name',
                            action='store',
                            help='Name of container.')
    
    arg_parser.add_argument('container_type',
                            action='store',
                            help='Type of container (e.g. StateMachine or Concurrence).')
    
    arg_parser.add_argument('states',
                            nargs = '*',
                            action='store',
                            help='A list of names of states to be contained.')
    
    arg_parser.add_argument('-s', '--scripts',
                            nargs = '*',
                            dest='script_dirs',
                            action='store',
                            default=[],
                            help='SMACHA script directories (directories containing yaml files).')
    
    arg_parser.add_argument('-o', '--output',
                            dest='output_file',
                            action='store',
                            default='./smacha_contain_output.py.',
                            help='Generated SMACH output (python file).')
    
    
    args = arg_parser.parse_args()
    
    # Take note of persistent/non-persistent container and sub-script variables
    container_persistent_vars = ['params']
    
    # Load parser
    parser = smacha.Parser(script_dirs = args.script_dirs)
    
    # Load and parse SMACHA script
    script = parser.parse(args.script_file)
    
    #
    # Find the list of states to be contained
    #
    states_buffer = list()
    i_state = 0
    i_script_container_state = 0
    for i_script_state, script_state in enumerate(script['states']):
        # Ensure we haven't run off a cliff
        if i_state >= len(args.states):
            break

        # Find the state name and variables in the current state
        script_state_name, script_state_vars = list(script_state.items())[0]

        # Record a script state buffer and the script state index of
        # the new container state.
        if script_state_name == args.states[i_state] and states_buffer:
            states_buffer.append(script_state)
            i_state = i_state + 1
        elif script_state_name != args.states[i_state] and states_buffer:
            raise ParsingError('State list does not match script state sequence!')
        elif script_state_name == args.states[i_state] and not states_buffer:
            states_buffer.append(script_state)
            i_script_container_state = i_script_state
            i_state = i_state + 1
        else:
            continue

    #
    # Construct skeleton of container state entry 
    #
    container_state_name = args.container_name
    container_state_vars = dict()
    container_state_vars['template'] = args.container_type
   
    # 
    # Generate new container state outcomes as appropriate and remap transitions
    #
    container_state_vars['outcomes'] = set()
    container_state_vars['transitions'] = dict()
    outcome_map = dict()
    for state in states_buffer:
        for outcome, transition in list(state.items())[0][1]['transitions'].items():
            if transition not in args.states:
                # Add the transition to the outcome_map and container state outcomes if necessary
                if transition not in outcome_map.keys():
                    new_container_outcome = container_state_name.lower() + '_outcome_' + str(len(outcome_map.keys()) + 1)
                    outcome_map[transition] = new_container_outcome
                    container_state_vars['outcomes'].update([new_container_outcome])
                    # Update the container transition
                    container_state_vars['transitions'][new_container_outcome] = transition
                # Update the state transition
                list(state.items())[0][1]['transitions'][outcome] = outcome_map[transition]
    container_state_vars['outcomes'] = list(container_state_vars['outcomes'])

    #
    # Adjust transitions of all states in script to point to container state as appropriate.
    #
    for state in script['states']:
        for outcome, transition in list(state.items())[0][1]['transitions'].items():
            if transition in args.states:
                list(state.items())[0][1]['transitions'][outcome] = container_state_name

    #
    # Handle container persistent variables by moving them outside of the container as appropriate.
    #
    for persistent_var in container_persistent_vars:
        # Create a dict for the persistent variable in container_state_vars if it doesn't exist yet.
        if persistent_var not in container_state_vars:
            container_state_vars[persistent_var] = dict()

        for state in states_buffer:
            if persistent_var in list(state.items())[0][1]:
                # We assume persistent_var is a dict of vars
                for var, val in list(state.items())[0][1][persistent_var].items():
                    # If it doesn't yet exist in the container state, add it
                    if var not in container_state_vars[persistent_var].keys():
                        container_state_vars[persistent_var][var] = val
                    # If it does exist, but the var value is different, generate a new var key
                    elif container_state_vars[persistent_var][var] != val:
                        # Generate a new var
                        i_new_key = 1
                        while var + '_' + str(i_new_key) in container_state_vars[persistent_var][var]:
                            i_new_key = i_new_key + 1
                        container_state_vars[persistent_var][var + '_' + str(i_new_key)] = val
                    # If it exists, and the var value is the same, skip it
                    else:
                        continue
                # Delete persistent variable from the state
                list(state.items())[0][1].pop(persistent_var, 0)

        # Delete the persistent variable from container_state_vars if it's still empty
        if not container_state_vars[persistent_var]:
            container_state_vars.pop(persistent_var, 0)

    #
    # Handle userdata and remapping by moving certain userdata entries outside of the container as appropriate.
    #
    container_state_vars['remapping'] = dict()

    # Create a dict for userdata in script_vars if it doesn't exist yet.
    if 'userdata' not in script:
        script['userdata'] = dict()

    for state in states_buffer:
        if 'userdata' in list(state.items())[0][1]:
            for var, val in list(state.items())[0][1]['userdata'].items():
                # Userdata should only be lifted out of the container if it
                # does not contain variable lookups.
                if not parser.contains_lookups(val, container_persistent_vars):
                    # If it doesn't yet exist in the script userdata, add it
                    if var not in script['userdata'].keys():
                        # Add it to script userdata
                        script['userdata'][var] = val

                        # Update the remapping
                        container_state_vars['remapping'][var] = var

                    # If it does exist, generate a new var key
                    else:
                        # Generate a new var
                        i_new_key = 1
                        while var + '_' + str(i_new_key) in script['userdata'][var]:
                            i_new_key = i_new_key + 1
                        script['userdata'][var + '_' + str(i_new_key)] = val

                        # Update the remapping
                        container_state_vars['remapping'][var] = var + '_' + str(i_new_key)

                    # Delete the variable from the userdata in the state
                    list(state.items())[0][1]['userdata'].pop(var, 0)

            # If the state userdata is now empty, delete it
            if not list(state.items())[0][1]['userdata']:
                list(state.items())[0][1].pop('userdata', 0)
    
    # Delete the remapping variable from the container_state_vars if it's still empty
    if not container_state_vars['remapping']:
        container_state_vars.pop('remapping', 0)

    # Delete the userdata variable from the script if it's still empty
    if not script['userdata']:
        script.pop('userdata', 0)

    # Add states_buffer to container
    container_state_vars['states'] = states_buffer

    # Construct container state
    container_state = dict()
    container_state[container_state_name] = container_state_vars

    # Remove old states from script and add container
    del script['states'][i_script_container_state+1:i_script_container_state+len(states_buffer)]
    script['states'][i_script_container_state] = container_state
    
    # Write the updated script to a YAML file
    parser.dump(args.output_file, script)

